# -*- coding: utf-8 -*-
"""stats141sl_ann.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U-qM35RSP04tbpnfbnmns99eoAudPfuU
"""

import torch
from torch import nn, optim
from torch.utils.data import Dataset, DataLoader
# other utils
import sys
import pandas as pd
import numpy as np
from tqdm import tqdm

Eye_dataframe = pd.read_csv("data.csv",index_col=0)
Eye_dataframe = Eye_dataframe.sample(frac=1).reset_index(drop=True)

print(Eye_dataframe.head())

class EyeDataset(Dataset):
    def __init__(self, Eye_df):
        super(EyeDataset, self).__init__()
        int_ethnicity = np.array([0 if item=="Persian" else 1 for item in Eye_df.Ethnicity])
        self.y = torch.tensor(int_ethnicity)
        self.x = torch.tensor(Eye_df[["Age","Sex","MRD-1(R)","PTB (R)","TPS (R)","MRD-1 (L)","PTB (L)","TPS (L)"]].to_numpy(),dtype=torch.float32)

    def __getitem__(self, index):
        return (self.x[index], self.y[index])
    
    def __len__(self):
        return len(self.x)


class EyeData_ANN(nn.Module):
    def __init__(self):
        super(EyeData_ANN, self).__init__()
        self.input = nn.Sequential(
            nn.Linear(6,32),
            nn.BatchNorm1d(num_features=32),
            nn.ReLU()
        )
        self.body = nn.Sequential(
            nn.Linear(32,128),
            nn.ReLU(),
            nn.Linear(128,512),
            nn.ReLU(),
            nn.Dropout(p=0.3),
            nn.Linear(512, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Dropout(p=0.3)
        )
        self.FC = nn.Sequential(
            nn.Linear(128, 2),
            nn.Softmax(dim=1)
        )
    
    def forward(self, x):
        x = self.input(x)
        x = self.body(x)
        y = self.FC(x)

        return y

def accuracy_function(prediction, y):
    _, classification = torch.max(prediction, 1)
    correct = (classification == y).float()
    accuracy = correct.sum() / len(correct)
    return accuracy

def train(model, train_loader, optimizer, loss_function, device):
    model.train()
    total_batch = len(train_loader)
    with tqdm(train_loader,"Run Train",total=len(train_loader)) as progress:
        for x_batch, y_batch in progress:
            optimizer.zero_grad()
            # print(x_batch)
            x_batch = x_batch.to(device)
            y_batch = y_batch.to(device)
            y_pred = model(x_batch).squeeze(1)
            loss = loss_function(y_pred,y_batch)
            acc = accuracy_function(y_pred, y_batch)
            # back propgation
            loss.backward()
            optimizer.step()
        print('Epoch Finished')

def evaluate(model, evaluation_set, loss_function, device):
    total_loss, total_acc = 0,0
    model.eval() # dropout will be deactivated
    with torch.no_grad():
        with tqdm(evaluation_set, "Run Eval", total=len(evaluation_set)) as progress:
            for x_batch, y_batch in evaluation_set:
                x_batch = x_batch.to(device)
                y_batch = y_batch.to(device)
                y_pred = model(x_batch).squeeze(1)
                loss = loss_function(y_pred, y_batch)
                acc = accuracy_function(y_pred, y_batch)

                total_loss += loss.item()
                total_acc += acc.item()
    return total_loss/len(evaluation_set), total_acc/len(evaluation_set)

device = 'cuda' if torch.cuda.is_available() else 'cpu'

model = EyeData_ANN()
optimizer = optim.Adam(model.parameters())
loss_function = nn.CrossEntropyLoss()

model = model.to(device)
loss_function = loss_function.to(device)

training_dataset = EyeDataset(Eye_dataframe.iloc[50:,])
testing_dataset = EyeDataset(Eye_dataframe.iloc[0:49,])


train_load = DataLoader(dataset=training_dataset,batch_size=8,shuffle=True)
test_load = DataLoader(dataset=testing_dataset,batch_size=8,shuffle=True)

for epoch in range(15):

    train(model,train_load,optimizer,loss_function, device)
    train_loss, train_acc = evaluate(model, train_load, loss_function, device)
    test_loss, test_acc = evaluate(model, test_load, loss_function, device)

    print(f'Epoch: {epoch+1:02}')
    print(f'\tTrain Loss: {train_loss:.3f} | Train Acc: {train_acc*100:.2f}%')
    print(f'\t Val. Loss: {test_loss:.3f} |  Val. Acc: {test_acc*100:.2f}%\n')